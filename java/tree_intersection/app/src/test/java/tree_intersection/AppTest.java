/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package tree_intersection;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class AppTest {
  @Test void appHasAGreeting() {
    App classUnderTest = new App();
    assertNotNull(classUnderTest.getGreeting());
  }


  //Throw Exception if one of trees is empty
  @Test void emptyString(){
    HashMapClass hashMapClass = new HashMapClass();
    BinaryTree firstTree = new BinaryTree();
    BinaryTree secondTree = new BinaryTree();
    Assertions.assertThrows(Exception.class, ()-> hashMapClass.treeIntersection(firstTree, secondTree));
  }

  @Test void happyPath() throws Exception{
    HashMapClass hashMapClass = new HashMapClass();
    BinaryTree binaryTree = new BinaryTree();

    binaryTree.setRoot(new Node(150));

    binaryTree.getRoot().setLeft(new Node(100));
    binaryTree.getRoot().getLeft().setLeft(new Node(75));
    binaryTree.getRoot().getLeft().setRight(new Node(160));
    binaryTree.getRoot().getLeft().getRight().setLeft(new Node(125));
    binaryTree.getRoot().getLeft().getRight().setRight(new Node(175));
    binaryTree.getRoot().setRight(new Node(250));
    binaryTree.getRoot().getRight().setLeft(new Node(200));
    binaryTree.getRoot().getRight().setRight(new Node(350));
    binaryTree.getRoot().getRight().getRight().setLeft(new Node(300));
    binaryTree.getRoot().getRight().getRight().setRight(new Node(500));
  }}

