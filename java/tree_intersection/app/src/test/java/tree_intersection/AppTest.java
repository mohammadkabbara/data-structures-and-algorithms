/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package tree_intersection;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.HashMap;

import static org.junit.jupiter.api.Assertions.*;
class AppTest {
  @Test void appHasAGreeting() {
    App classUnderTest = new App();
    assertNotNull(classUnderTest.getGreeting(), "app should have a greeting");
  }


  //Throw Exception if one of trees is empty
  @Test void emptyString(){
    HashMapClass hashMapClass = new HashMapClass();
    BinaryTree tree1 = new BinaryTree();
    BinaryTree tree2 = new BinaryTree();
    Assertions.assertThrows(Exception.class, ()-> hashMapClass.treeIntersection(tree1, tree2));
  }

  @Test void happyPath() throws Exception{
    HashMapClass hashMapClass = new HashMapClass();
    BinaryTree binaryTree = new BinaryTree();

    binaryTree.setRoot(new Node(150));

    binaryTree.getRoot().setLeft(new Node(100));
    binaryTree.getRoot().getLeft().setLeft(new Node(75));
    binaryTree.getRoot().getLeft().setRight(new Node(160));
    binaryTree.getRoot().getLeft().getRight().setLeft(new Node(125));
    binaryTree.getRoot().getLeft().getRight().setRight(new Node(175));
    binaryTree.getRoot().setRight(new Node(250));
    binaryTree.getRoot().getRight().setLeft(new Node(200));
    binaryTree.getRoot().getRight().setRight(new Node(350));
    binaryTree.getRoot().getRight().getRight().setLeft(new Node(300));
    binaryTree.getRoot().getRight().getRight().setRight(new Node(500));

  }

  @Test void emptyHashMaps(){
    HashMapClass hashMapClass = new HashMapClass();
    HashMap<String, String> left = new HashMap<>();
    HashMap<String, String> right = new HashMap<>();
    Assertions.assertThrows(Exception.class, ()-> hashMapClass.leftJoin(left, right));
  }

  @Test void happyPathLeftJoin() throws Exception{
    HashMapClass hashMapClass = new HashMapClass();
    HashMap<String, String> left = new HashMap<>();
    HashMap<String, String> right = new HashMap<>();
    left.put("fond", "enamored");
    left.put("wrath", "anger");
    left.put("diligent", "employed");

    right.put("fond", "averse");
    right.put("wrath", "delight");
    right.put("diligent", "idle");

    assertEquals("[[diligent, employed, idle], [wrath, anger, delight], [fond, enamored, averse]]", hashMapClass.leftJoin(left, right));
  }

}
